/* DO NOT EDIT THIS FILE - it is generated by jsgl_gen */
ECMA_BEGIN_VOID_FUNC (js_glClearIndex)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat c;
  if (!ecma_to_GLfloat (argv[0], c))
    ECMA_ERROR ("argument 0 has wrong type");
  glClearIndex (c);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glClearColor)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLclampf red;
  if (!ecma_to_GLclampf (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLclampf green;
  if (!ecma_to_GLclampf (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLclampf blue;
  if (!ecma_to_GLclampf (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  GLclampf alpha;
  if (!ecma_to_GLclampf (argv[3], alpha))
    ECMA_ERROR ("argument 3 has wrong type");
  glClearColor (red, green, blue, alpha);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glClear)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLbitfield mask;
  if (!ecma_to_GLbitfield (argv[0], mask))
    ECMA_ERROR ("argument 0 has wrong type");
  glClear (mask);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glIndexMask)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLuint mask;
  if (!ecma_to_GLuint (argv[0], mask))
    ECMA_ERROR ("argument 0 has wrong type");
  glIndexMask (mask);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColorMask)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLboolean red;
  if (!ecma_to_GLboolean (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLboolean green;
  if (!ecma_to_GLboolean (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLboolean blue;
  if (!ecma_to_GLboolean (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  GLboolean alpha;
  if (!ecma_to_GLboolean (argv[3], alpha))
    ECMA_ERROR ("argument 3 has wrong type");
  glColorMask (red, green, blue, alpha);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glAlphaFunc)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum func;
  if (!ecma_to_GLenum (argv[0], func))
    ECMA_ERROR ("argument 0 has wrong type");
  GLclampf ref;
  if (!ecma_to_GLclampf (argv[1], ref))
    ECMA_ERROR ("argument 1 has wrong type");
  glAlphaFunc (func, ref);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glBlendFunc)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum sfactor;
  if (!ecma_to_GLenum (argv[0], sfactor))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum dfactor;
  if (!ecma_to_GLenum (argv[1], dfactor))
    ECMA_ERROR ("argument 1 has wrong type");
  glBlendFunc (sfactor, dfactor);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glLogicOp)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum opcode;
  if (!ecma_to_GLenum (argv[0], opcode))
    ECMA_ERROR ("argument 0 has wrong type");
  glLogicOp (opcode);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glCullFace)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum mode;
  if (!ecma_to_GLenum (argv[0], mode))
    ECMA_ERROR ("argument 0 has wrong type");
  glCullFace (mode);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glFrontFace)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum mode;
  if (!ecma_to_GLenum (argv[0], mode))
    ECMA_ERROR ("argument 0 has wrong type");
  glFrontFace (mode);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glPointSize)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat size;
  if (!ecma_to_GLfloat (argv[0], size))
    ECMA_ERROR ("argument 0 has wrong type");
  glPointSize (size);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glLineWidth)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat width;
  if (!ecma_to_GLfloat (argv[0], width))
    ECMA_ERROR ("argument 0 has wrong type");
  glLineWidth (width);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glLineStipple)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLint factor;
  if (!ecma_to_GLint (argv[0], factor))
    ECMA_ERROR ("argument 0 has wrong type");
  GLushort pattern;
  if (!ecma_to_GLushort (argv[1], pattern))
    ECMA_ERROR ("argument 1 has wrong type");
  glLineStipple (factor, pattern);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glPolygonMode)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum face;
  if (!ecma_to_GLenum (argv[0], face))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum mode;
  if (!ecma_to_GLenum (argv[1], mode))
    ECMA_ERROR ("argument 1 has wrong type");
  glPolygonMode (face, mode);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glPolygonOffset)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLfloat factor;
  if (!ecma_to_GLfloat (argv[0], factor))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat units;
  if (!ecma_to_GLfloat (argv[1], units))
    ECMA_ERROR ("argument 1 has wrong type");
  glPolygonOffset (factor, units);
  return JS_TRUE;
}

/* TODO: glPolygonStipple */

/* TODO: glGetPolygonStipple */

ECMA_BEGIN_VOID_FUNC (js_glEdgeFlag)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLboolean flag;
  if (!ecma_to_GLboolean (argv[0], flag))
    ECMA_ERROR ("argument 0 has wrong type");
  glEdgeFlag (flag);
  return JS_TRUE;
}

/* TODO: glEdgeFlagv */

ECMA_BEGIN_VOID_FUNC (js_glScissor)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLint x;
  if (!ecma_to_GLint (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLsizei width;
  if (!ecma_to_GLsizei (argv[2], width))
    ECMA_ERROR ("argument 2 has wrong type");
  GLsizei height;
  if (!ecma_to_GLsizei (argv[3], height))
    ECMA_ERROR ("argument 3 has wrong type");
  glScissor (x, y, width, height);
  return JS_TRUE;
}

/* TODO: glClipPlane */

/* TODO: glGetClipPlane */

ECMA_BEGIN_VOID_FUNC (js_glDrawBuffer)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum mode;
  if (!ecma_to_GLenum (argv[0], mode))
    ECMA_ERROR ("argument 0 has wrong type");
  glDrawBuffer (mode);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glReadBuffer)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum mode;
  if (!ecma_to_GLenum (argv[0], mode))
    ECMA_ERROR ("argument 0 has wrong type");
  glReadBuffer (mode);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glEnable)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum cap;
  if (!ecma_to_GLenum (argv[0], cap))
    ECMA_ERROR ("argument 0 has wrong type");
  glEnable (cap);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glDisable)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum cap;
  if (!ecma_to_GLenum (argv[0], cap))
    ECMA_ERROR ("argument 0 has wrong type");
  glDisable (cap);
  return JS_TRUE;
}

ECMA_BEGIN_FUNC (js_glIsEnabled)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum cap;
  if (!ecma_to_GLenum (argv[0], cap))
    ECMA_ERROR ("argument 0 has wrong type");
  GLboolean nres = glIsEnabled (cap);
  if (!ecma_from_GLboolean (nres, rval))
    ECMA_ERROR ("could not convert result of type GLboolean");
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glEnableClientState)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum cap;
  if (!ecma_to_GLenum (argv[0], cap))
    ECMA_ERROR ("argument 0 has wrong type");
  glEnableClientState (cap);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glDisableClientState)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum cap;
  if (!ecma_to_GLenum (argv[0], cap))
    ECMA_ERROR ("argument 0 has wrong type");
  glDisableClientState (cap);
  return JS_TRUE;
}

/* TODO: glGetBooleanv */

/* TODO: glGetDoublev */

/* TODO: glGetFloatv */

/* TODO: glGetIntegerv */

ECMA_BEGIN_VOID_FUNC (js_glPushAttrib)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLbitfield mask;
  if (!ecma_to_GLbitfield (argv[0], mask))
    ECMA_ERROR ("argument 0 has wrong type");
  glPushAttrib (mask);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC_VOID (js_glPopAttrib)
{
  ECMA_CHECK_NUM_ARGS (0);
  assert (cx == ECMAScript::cx);
  glPopAttrib ();
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glPushClientAttrib)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLbitfield mask;
  if (!ecma_to_GLbitfield (argv[0], mask))
    ECMA_ERROR ("argument 0 has wrong type");
  glPushClientAttrib (mask);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC_VOID (js_glPopClientAttrib)
{
  ECMA_CHECK_NUM_ARGS (0);
  assert (cx == ECMAScript::cx);
  glPopClientAttrib ();
  return JS_TRUE;
}

ECMA_BEGIN_FUNC (js_glRenderMode)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum mode;
  if (!ecma_to_GLenum (argv[0], mode))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint nres = glRenderMode (mode);
  if (!ecma_from_GLint (nres, rval))
    ECMA_ERROR ("could not convert result of type GLint");
  return JS_TRUE;
}

ECMA_BEGIN_FUNC_VOID (js_glGetError)
{
  ECMA_CHECK_NUM_ARGS (0);
  assert (cx == ECMAScript::cx);
  GLenum nres = glGetError ();
  if (!ecma_from_GLenum (nres, rval))
    ECMA_ERROR ("could not convert result of type GLenum");
  return JS_TRUE;
}

ECMA_BEGIN_FUNC (js_glGetString)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum name;
  if (!ecma_to_GLenum (argv[0], name))
    ECMA_ERROR ("argument 0 has wrong type");
  const GLubyte *nres = glGetString (name);
  if (!ecma_from_const_GLubyte_ptr (nres, rval))
    ECMA_ERROR ("could not convert result of type const GLubyte *");
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC_VOID (js_glFinish)
{
  ECMA_CHECK_NUM_ARGS (0);
  assert (cx == ECMAScript::cx);
  glFinish ();
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC_VOID (js_glFlush)
{
  ECMA_CHECK_NUM_ARGS (0);
  assert (cx == ECMAScript::cx);
  glFlush ();
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glHint)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum mode;
  if (!ecma_to_GLenum (argv[1], mode))
    ECMA_ERROR ("argument 1 has wrong type");
  glHint (target, mode);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glClearDepth)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLclampd depth;
  if (!ecma_to_GLclampd (argv[0], depth))
    ECMA_ERROR ("argument 0 has wrong type");
  glClearDepth (depth);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glDepthFunc)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum func;
  if (!ecma_to_GLenum (argv[0], func))
    ECMA_ERROR ("argument 0 has wrong type");
  glDepthFunc (func);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glDepthMask)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLboolean flag;
  if (!ecma_to_GLboolean (argv[0], flag))
    ECMA_ERROR ("argument 0 has wrong type");
  glDepthMask (flag);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glDepthRange)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLclampd near_val;
  if (!ecma_to_GLclampd (argv[0], near_val))
    ECMA_ERROR ("argument 0 has wrong type");
  GLclampd far_val;
  if (!ecma_to_GLclampd (argv[1], far_val))
    ECMA_ERROR ("argument 1 has wrong type");
  glDepthRange (near_val, far_val);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glClearAccum)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLfloat red;
  if (!ecma_to_GLfloat (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat green;
  if (!ecma_to_GLfloat (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat blue;
  if (!ecma_to_GLfloat (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  GLfloat alpha;
  if (!ecma_to_GLfloat (argv[3], alpha))
    ECMA_ERROR ("argument 3 has wrong type");
  glClearAccum (red, green, blue, alpha);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glAccum)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum op;
  if (!ecma_to_GLenum (argv[0], op))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat value;
  if (!ecma_to_GLfloat (argv[1], value))
    ECMA_ERROR ("argument 1 has wrong type");
  glAccum (op, value);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMatrixMode)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum mode;
  if (!ecma_to_GLenum (argv[0], mode))
    ECMA_ERROR ("argument 0 has wrong type");
  glMatrixMode (mode);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glOrtho)
{
  ECMA_CHECK_NUM_ARGS (6);
  assert (cx == ECMAScript::cx);
  GLdouble left;
  if (!ecma_to_GLdouble (argv[0], left))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble right;
  if (!ecma_to_GLdouble (argv[1], right))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble bottom;
  if (!ecma_to_GLdouble (argv[2], bottom))
    ECMA_ERROR ("argument 2 has wrong type");
  GLdouble top;
  if (!ecma_to_GLdouble (argv[3], top))
    ECMA_ERROR ("argument 3 has wrong type");
  GLdouble near_val;
  if (!ecma_to_GLdouble (argv[4], near_val))
    ECMA_ERROR ("argument 4 has wrong type");
  GLdouble far_val;
  if (!ecma_to_GLdouble (argv[5], far_val))
    ECMA_ERROR ("argument 5 has wrong type");
  glOrtho (left, right, bottom, top, near_val, far_val);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glFrustum)
{
  ECMA_CHECK_NUM_ARGS (6);
  assert (cx == ECMAScript::cx);
  GLdouble left;
  if (!ecma_to_GLdouble (argv[0], left))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble right;
  if (!ecma_to_GLdouble (argv[1], right))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble bottom;
  if (!ecma_to_GLdouble (argv[2], bottom))
    ECMA_ERROR ("argument 2 has wrong type");
  GLdouble top;
  if (!ecma_to_GLdouble (argv[3], top))
    ECMA_ERROR ("argument 3 has wrong type");
  GLdouble near_val;
  if (!ecma_to_GLdouble (argv[4], near_val))
    ECMA_ERROR ("argument 4 has wrong type");
  GLdouble far_val;
  if (!ecma_to_GLdouble (argv[5], far_val))
    ECMA_ERROR ("argument 5 has wrong type");
  glFrustum (left, right, bottom, top, near_val, far_val);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glViewport)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLint x;
  if (!ecma_to_GLint (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLsizei width;
  if (!ecma_to_GLsizei (argv[2], width))
    ECMA_ERROR ("argument 2 has wrong type");
  GLsizei height;
  if (!ecma_to_GLsizei (argv[3], height))
    ECMA_ERROR ("argument 3 has wrong type");
  glViewport (x, y, width, height);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC_VOID (js_glPushMatrix)
{
  ECMA_CHECK_NUM_ARGS (0);
  assert (cx == ECMAScript::cx);
  glPushMatrix ();
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC_VOID (js_glPopMatrix)
{
  ECMA_CHECK_NUM_ARGS (0);
  assert (cx == ECMAScript::cx);
  glPopMatrix ();
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC_VOID (js_glLoadIdentity)
{
  ECMA_CHECK_NUM_ARGS (0);
  assert (cx == ECMAScript::cx);
  glLoadIdentity ();
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glLoadMatrixd)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble m[16];
  if (!ecma_to_GLdouble_VEC (argv[0], m, 16))
    ECMA_ERROR ("argument 0 has wrong type");
  glLoadMatrixd (m);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glLoadMatrixf)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat m[16];
  if (!ecma_to_GLfloat_VEC (argv[0], m, 16))
    ECMA_ERROR ("argument 0 has wrong type");
  glLoadMatrixf (m);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultMatrixd)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble m[16];
  if (!ecma_to_GLdouble_VEC (argv[0], m, 16))
    ECMA_ERROR ("argument 0 has wrong type");
  glMultMatrixd (m);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultMatrixf)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat m[16];
  if (!ecma_to_GLfloat_VEC (argv[0], m, 16))
    ECMA_ERROR ("argument 0 has wrong type");
  glMultMatrixf (m);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRotated)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLdouble angle;
  if (!ecma_to_GLdouble (argv[0], angle))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble x;
  if (!ecma_to_GLdouble (argv[1], x))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble y;
  if (!ecma_to_GLdouble (argv[2], y))
    ECMA_ERROR ("argument 2 has wrong type");
  GLdouble z;
  if (!ecma_to_GLdouble (argv[3], z))
    ECMA_ERROR ("argument 3 has wrong type");
  glRotated (angle, x, y, z);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRotatef)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLfloat angle;
  if (!ecma_to_GLfloat (argv[0], angle))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat x;
  if (!ecma_to_GLfloat (argv[1], x))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat y;
  if (!ecma_to_GLfloat (argv[2], y))
    ECMA_ERROR ("argument 2 has wrong type");
  GLfloat z;
  if (!ecma_to_GLfloat (argv[3], z))
    ECMA_ERROR ("argument 3 has wrong type");
  glRotatef (angle, x, y, z);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glScaled)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLdouble x;
  if (!ecma_to_GLdouble (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble y;
  if (!ecma_to_GLdouble (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble z;
  if (!ecma_to_GLdouble (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  glScaled (x, y, z);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glScalef)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLfloat x;
  if (!ecma_to_GLfloat (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat y;
  if (!ecma_to_GLfloat (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat z;
  if (!ecma_to_GLfloat (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  glScalef (x, y, z);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTranslated)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLdouble x;
  if (!ecma_to_GLdouble (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble y;
  if (!ecma_to_GLdouble (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble z;
  if (!ecma_to_GLdouble (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  glTranslated (x, y, z);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTranslatef)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLfloat x;
  if (!ecma_to_GLfloat (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat y;
  if (!ecma_to_GLfloat (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat z;
  if (!ecma_to_GLfloat (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  glTranslatef (x, y, z);
  return JS_TRUE;
}

ECMA_BEGIN_FUNC (js_glIsList)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLuint list;
  if (!ecma_to_GLuint (argv[0], list))
    ECMA_ERROR ("argument 0 has wrong type");
  GLboolean nres = glIsList (list);
  if (!ecma_from_GLboolean (nres, rval))
    ECMA_ERROR ("could not convert result of type GLboolean");
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glDeleteLists)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLuint list;
  if (!ecma_to_GLuint (argv[0], list))
    ECMA_ERROR ("argument 0 has wrong type");
  GLsizei range;
  if (!ecma_to_GLsizei (argv[1], range))
    ECMA_ERROR ("argument 1 has wrong type");
  glDeleteLists (list, range);
  return JS_TRUE;
}

ECMA_BEGIN_FUNC (js_glGenLists)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLsizei range;
  if (!ecma_to_GLsizei (argv[0], range))
    ECMA_ERROR ("argument 0 has wrong type");
  GLuint nres = glGenLists (range);
  if (!ecma_from_GLuint (nres, rval))
    ECMA_ERROR ("could not convert result of type GLuint");
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glNewList)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLuint list;
  if (!ecma_to_GLuint (argv[0], list))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum mode;
  if (!ecma_to_GLenum (argv[1], mode))
    ECMA_ERROR ("argument 1 has wrong type");
  glNewList (list, mode);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC_VOID (js_glEndList)
{
  ECMA_CHECK_NUM_ARGS (0);
  assert (cx == ECMAScript::cx);
  glEndList ();
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glCallList)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLuint list;
  if (!ecma_to_GLuint (argv[0], list))
    ECMA_ERROR ("argument 0 has wrong type");
  glCallList (list);
  return JS_TRUE;
}

/* TODO: glCallLists */

ECMA_BEGIN_VOID_FUNC (js_glListBase)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLuint base;
  if (!ecma_to_GLuint (argv[0], base))
    ECMA_ERROR ("argument 0 has wrong type");
  glListBase (base);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glBegin)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum mode;
  if (!ecma_to_GLenum (argv[0], mode))
    ECMA_ERROR ("argument 0 has wrong type");
  glBegin (mode);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC_VOID (js_glEnd)
{
  ECMA_CHECK_NUM_ARGS (0);
  assert (cx == ECMAScript::cx);
  glEnd ();
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex2d)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLdouble x;
  if (!ecma_to_GLdouble (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble y;
  if (!ecma_to_GLdouble (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  glVertex2d (x, y);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex2f)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLfloat x;
  if (!ecma_to_GLfloat (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat y;
  if (!ecma_to_GLfloat (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  glVertex2f (x, y);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex2i)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLint x;
  if (!ecma_to_GLint (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  glVertex2i (x, y);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex2s)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLshort x;
  if (!ecma_to_GLshort (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort y;
  if (!ecma_to_GLshort (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  glVertex2s (x, y);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex3d)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLdouble x;
  if (!ecma_to_GLdouble (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble y;
  if (!ecma_to_GLdouble (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble z;
  if (!ecma_to_GLdouble (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  glVertex3d (x, y, z);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex3f)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLfloat x;
  if (!ecma_to_GLfloat (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat y;
  if (!ecma_to_GLfloat (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat z;
  if (!ecma_to_GLfloat (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  glVertex3f (x, y, z);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex3i)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLint x;
  if (!ecma_to_GLint (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint z;
  if (!ecma_to_GLint (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  glVertex3i (x, y, z);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex3s)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLshort x;
  if (!ecma_to_GLshort (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort y;
  if (!ecma_to_GLshort (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLshort z;
  if (!ecma_to_GLshort (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  glVertex3s (x, y, z);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex4d)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLdouble x;
  if (!ecma_to_GLdouble (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble y;
  if (!ecma_to_GLdouble (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble z;
  if (!ecma_to_GLdouble (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  GLdouble w;
  if (!ecma_to_GLdouble (argv[3], w))
    ECMA_ERROR ("argument 3 has wrong type");
  glVertex4d (x, y, z, w);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex4f)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLfloat x;
  if (!ecma_to_GLfloat (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat y;
  if (!ecma_to_GLfloat (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat z;
  if (!ecma_to_GLfloat (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  GLfloat w;
  if (!ecma_to_GLfloat (argv[3], w))
    ECMA_ERROR ("argument 3 has wrong type");
  glVertex4f (x, y, z, w);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex4i)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLint x;
  if (!ecma_to_GLint (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint z;
  if (!ecma_to_GLint (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint w;
  if (!ecma_to_GLint (argv[3], w))
    ECMA_ERROR ("argument 3 has wrong type");
  glVertex4i (x, y, z, w);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex4s)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLshort x;
  if (!ecma_to_GLshort (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort y;
  if (!ecma_to_GLshort (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLshort z;
  if (!ecma_to_GLshort (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  GLshort w;
  if (!ecma_to_GLshort (argv[3], w))
    ECMA_ERROR ("argument 3 has wrong type");
  glVertex4s (x, y, z, w);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex2dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble v[2];
  if (!ecma_to_GLdouble_VEC (argv[0], v, 2))
    ECMA_ERROR ("argument 0 has wrong type");
  glVertex2dv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex2fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat v[2];
  if (!ecma_to_GLfloat_VEC (argv[0], v, 2))
    ECMA_ERROR ("argument 0 has wrong type");
  glVertex2fv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex2iv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint v[2];
  if (!ecma_to_GLint_VEC (argv[0], v, 2))
    ECMA_ERROR ("argument 0 has wrong type");
  glVertex2iv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex2sv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort v[2];
  if (!ecma_to_GLshort_VEC (argv[0], v, 2))
    ECMA_ERROR ("argument 0 has wrong type");
  glVertex2sv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex3dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble v[3];
  if (!ecma_to_GLdouble_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glVertex3dv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex3fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat v[3];
  if (!ecma_to_GLfloat_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glVertex3fv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex3iv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint v[3];
  if (!ecma_to_GLint_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glVertex3iv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex3sv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort v[3];
  if (!ecma_to_GLshort_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glVertex3sv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex4dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble v[4];
  if (!ecma_to_GLdouble_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glVertex4dv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex4fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat v[4];
  if (!ecma_to_GLfloat_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glVertex4fv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex4iv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint v[4];
  if (!ecma_to_GLint_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glVertex4iv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glVertex4sv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort v[4];
  if (!ecma_to_GLshort_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glVertex4sv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glNormal3b)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLbyte nx;
  if (!ecma_to_GLbyte (argv[0], nx))
    ECMA_ERROR ("argument 0 has wrong type");
  GLbyte ny;
  if (!ecma_to_GLbyte (argv[1], ny))
    ECMA_ERROR ("argument 1 has wrong type");
  GLbyte nz;
  if (!ecma_to_GLbyte (argv[2], nz))
    ECMA_ERROR ("argument 2 has wrong type");
  glNormal3b (nx, ny, nz);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glNormal3d)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLdouble nx;
  if (!ecma_to_GLdouble (argv[0], nx))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble ny;
  if (!ecma_to_GLdouble (argv[1], ny))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble nz;
  if (!ecma_to_GLdouble (argv[2], nz))
    ECMA_ERROR ("argument 2 has wrong type");
  glNormal3d (nx, ny, nz);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glNormal3f)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLfloat nx;
  if (!ecma_to_GLfloat (argv[0], nx))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat ny;
  if (!ecma_to_GLfloat (argv[1], ny))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat nz;
  if (!ecma_to_GLfloat (argv[2], nz))
    ECMA_ERROR ("argument 2 has wrong type");
  glNormal3f (nx, ny, nz);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glNormal3i)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLint nx;
  if (!ecma_to_GLint (argv[0], nx))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint ny;
  if (!ecma_to_GLint (argv[1], ny))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint nz;
  if (!ecma_to_GLint (argv[2], nz))
    ECMA_ERROR ("argument 2 has wrong type");
  glNormal3i (nx, ny, nz);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glNormal3s)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLshort nx;
  if (!ecma_to_GLshort (argv[0], nx))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort ny;
  if (!ecma_to_GLshort (argv[1], ny))
    ECMA_ERROR ("argument 1 has wrong type");
  GLshort nz;
  if (!ecma_to_GLshort (argv[2], nz))
    ECMA_ERROR ("argument 2 has wrong type");
  glNormal3s (nx, ny, nz);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glNormal3bv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLbyte v[3];
  if (!ecma_to_GLbyte_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glNormal3bv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glNormal3dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble v[3];
  if (!ecma_to_GLdouble_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glNormal3dv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glNormal3fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat v[3];
  if (!ecma_to_GLfloat_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glNormal3fv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glNormal3iv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint v[3];
  if (!ecma_to_GLint_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glNormal3iv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glNormal3sv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort v[3];
  if (!ecma_to_GLshort_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glNormal3sv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glIndexd)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble c;
  if (!ecma_to_GLdouble (argv[0], c))
    ECMA_ERROR ("argument 0 has wrong type");
  glIndexd (c);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glIndexf)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat c;
  if (!ecma_to_GLfloat (argv[0], c))
    ECMA_ERROR ("argument 0 has wrong type");
  glIndexf (c);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glIndexi)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint c;
  if (!ecma_to_GLint (argv[0], c))
    ECMA_ERROR ("argument 0 has wrong type");
  glIndexi (c);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glIndexs)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort c;
  if (!ecma_to_GLshort (argv[0], c))
    ECMA_ERROR ("argument 0 has wrong type");
  glIndexs (c);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glIndexub)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLubyte c;
  if (!ecma_to_GLubyte (argv[0], c))
    ECMA_ERROR ("argument 0 has wrong type");
  glIndexub (c);
  return JS_TRUE;
}

/* TODO: glIndexdv */

/* TODO: glIndexfv */

/* TODO: glIndexiv */

/* TODO: glIndexsv */

/* TODO: glIndexubv */

ECMA_BEGIN_VOID_FUNC (js_glColor3b)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLbyte red;
  if (!ecma_to_GLbyte (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLbyte green;
  if (!ecma_to_GLbyte (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLbyte blue;
  if (!ecma_to_GLbyte (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  glColor3b (red, green, blue);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3d)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLdouble red;
  if (!ecma_to_GLdouble (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble green;
  if (!ecma_to_GLdouble (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble blue;
  if (!ecma_to_GLdouble (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  glColor3d (red, green, blue);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3f)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLfloat red;
  if (!ecma_to_GLfloat (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat green;
  if (!ecma_to_GLfloat (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat blue;
  if (!ecma_to_GLfloat (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  glColor3f (red, green, blue);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3i)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLint red;
  if (!ecma_to_GLint (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint green;
  if (!ecma_to_GLint (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint blue;
  if (!ecma_to_GLint (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  glColor3i (red, green, blue);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3s)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLshort red;
  if (!ecma_to_GLshort (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort green;
  if (!ecma_to_GLshort (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLshort blue;
  if (!ecma_to_GLshort (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  glColor3s (red, green, blue);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3ub)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLubyte red;
  if (!ecma_to_GLubyte (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLubyte green;
  if (!ecma_to_GLubyte (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLubyte blue;
  if (!ecma_to_GLubyte (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  glColor3ub (red, green, blue);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3ui)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLuint red;
  if (!ecma_to_GLuint (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLuint green;
  if (!ecma_to_GLuint (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLuint blue;
  if (!ecma_to_GLuint (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  glColor3ui (red, green, blue);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3us)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLushort red;
  if (!ecma_to_GLushort (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLushort green;
  if (!ecma_to_GLushort (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLushort blue;
  if (!ecma_to_GLushort (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  glColor3us (red, green, blue);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4b)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLbyte red;
  if (!ecma_to_GLbyte (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLbyte green;
  if (!ecma_to_GLbyte (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLbyte blue;
  if (!ecma_to_GLbyte (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  GLbyte alpha;
  if (!ecma_to_GLbyte (argv[3], alpha))
    ECMA_ERROR ("argument 3 has wrong type");
  glColor4b (red, green, blue, alpha);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4d)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLdouble red;
  if (!ecma_to_GLdouble (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble green;
  if (!ecma_to_GLdouble (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble blue;
  if (!ecma_to_GLdouble (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  GLdouble alpha;
  if (!ecma_to_GLdouble (argv[3], alpha))
    ECMA_ERROR ("argument 3 has wrong type");
  glColor4d (red, green, blue, alpha);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4f)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLfloat red;
  if (!ecma_to_GLfloat (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat green;
  if (!ecma_to_GLfloat (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat blue;
  if (!ecma_to_GLfloat (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  GLfloat alpha;
  if (!ecma_to_GLfloat (argv[3], alpha))
    ECMA_ERROR ("argument 3 has wrong type");
  glColor4f (red, green, blue, alpha);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4i)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLint red;
  if (!ecma_to_GLint (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint green;
  if (!ecma_to_GLint (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint blue;
  if (!ecma_to_GLint (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint alpha;
  if (!ecma_to_GLint (argv[3], alpha))
    ECMA_ERROR ("argument 3 has wrong type");
  glColor4i (red, green, blue, alpha);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4s)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLshort red;
  if (!ecma_to_GLshort (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort green;
  if (!ecma_to_GLshort (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLshort blue;
  if (!ecma_to_GLshort (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  GLshort alpha;
  if (!ecma_to_GLshort (argv[3], alpha))
    ECMA_ERROR ("argument 3 has wrong type");
  glColor4s (red, green, blue, alpha);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4ub)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLubyte red;
  if (!ecma_to_GLubyte (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLubyte green;
  if (!ecma_to_GLubyte (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLubyte blue;
  if (!ecma_to_GLubyte (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  GLubyte alpha;
  if (!ecma_to_GLubyte (argv[3], alpha))
    ECMA_ERROR ("argument 3 has wrong type");
  glColor4ub (red, green, blue, alpha);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4ui)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLuint red;
  if (!ecma_to_GLuint (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLuint green;
  if (!ecma_to_GLuint (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLuint blue;
  if (!ecma_to_GLuint (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  GLuint alpha;
  if (!ecma_to_GLuint (argv[3], alpha))
    ECMA_ERROR ("argument 3 has wrong type");
  glColor4ui (red, green, blue, alpha);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4us)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLushort red;
  if (!ecma_to_GLushort (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLushort green;
  if (!ecma_to_GLushort (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLushort blue;
  if (!ecma_to_GLushort (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  GLushort alpha;
  if (!ecma_to_GLushort (argv[3], alpha))
    ECMA_ERROR ("argument 3 has wrong type");
  glColor4us (red, green, blue, alpha);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3bv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLbyte v[3];
  if (!ecma_to_GLbyte_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor3bv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble v[3];
  if (!ecma_to_GLdouble_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor3dv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat v[3];
  if (!ecma_to_GLfloat_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor3fv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3iv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint v[3];
  if (!ecma_to_GLint_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor3iv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3sv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort v[3];
  if (!ecma_to_GLshort_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor3sv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3ubv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLubyte v[3];
  if (!ecma_to_GLubyte_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor3ubv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3uiv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLuint v[3];
  if (!ecma_to_GLuint_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor3uiv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor3usv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLushort v[3];
  if (!ecma_to_GLushort_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor3usv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4bv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLbyte v[4];
  if (!ecma_to_GLbyte_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor4bv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble v[4];
  if (!ecma_to_GLdouble_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor4dv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat v[4];
  if (!ecma_to_GLfloat_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor4fv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4iv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint v[4];
  if (!ecma_to_GLint_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor4iv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4sv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort v[4];
  if (!ecma_to_GLshort_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor4sv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4ubv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLubyte v[4];
  if (!ecma_to_GLubyte_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor4ubv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4uiv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLuint v[4];
  if (!ecma_to_GLuint_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor4uiv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glColor4usv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLushort v[4];
  if (!ecma_to_GLushort_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glColor4usv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord1d)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble s;
  if (!ecma_to_GLdouble (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord1d (s);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord1f)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat s;
  if (!ecma_to_GLfloat (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord1f (s);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord1i)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint s;
  if (!ecma_to_GLint (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord1i (s);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord1s)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort s;
  if (!ecma_to_GLshort (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord1s (s);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord2d)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLdouble s;
  if (!ecma_to_GLdouble (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble t;
  if (!ecma_to_GLdouble (argv[1], t))
    ECMA_ERROR ("argument 1 has wrong type");
  glTexCoord2d (s, t);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord2f)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLfloat s;
  if (!ecma_to_GLfloat (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat t;
  if (!ecma_to_GLfloat (argv[1], t))
    ECMA_ERROR ("argument 1 has wrong type");
  glTexCoord2f (s, t);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord2i)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLint s;
  if (!ecma_to_GLint (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint t;
  if (!ecma_to_GLint (argv[1], t))
    ECMA_ERROR ("argument 1 has wrong type");
  glTexCoord2i (s, t);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord2s)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLshort s;
  if (!ecma_to_GLshort (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort t;
  if (!ecma_to_GLshort (argv[1], t))
    ECMA_ERROR ("argument 1 has wrong type");
  glTexCoord2s (s, t);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord3d)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLdouble s;
  if (!ecma_to_GLdouble (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble t;
  if (!ecma_to_GLdouble (argv[1], t))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble r;
  if (!ecma_to_GLdouble (argv[2], r))
    ECMA_ERROR ("argument 2 has wrong type");
  glTexCoord3d (s, t, r);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord3f)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLfloat s;
  if (!ecma_to_GLfloat (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat t;
  if (!ecma_to_GLfloat (argv[1], t))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat r;
  if (!ecma_to_GLfloat (argv[2], r))
    ECMA_ERROR ("argument 2 has wrong type");
  glTexCoord3f (s, t, r);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord3i)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLint s;
  if (!ecma_to_GLint (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint t;
  if (!ecma_to_GLint (argv[1], t))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint r;
  if (!ecma_to_GLint (argv[2], r))
    ECMA_ERROR ("argument 2 has wrong type");
  glTexCoord3i (s, t, r);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord3s)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLshort s;
  if (!ecma_to_GLshort (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort t;
  if (!ecma_to_GLshort (argv[1], t))
    ECMA_ERROR ("argument 1 has wrong type");
  GLshort r;
  if (!ecma_to_GLshort (argv[2], r))
    ECMA_ERROR ("argument 2 has wrong type");
  glTexCoord3s (s, t, r);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord4d)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLdouble s;
  if (!ecma_to_GLdouble (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble t;
  if (!ecma_to_GLdouble (argv[1], t))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble r;
  if (!ecma_to_GLdouble (argv[2], r))
    ECMA_ERROR ("argument 2 has wrong type");
  GLdouble q;
  if (!ecma_to_GLdouble (argv[3], q))
    ECMA_ERROR ("argument 3 has wrong type");
  glTexCoord4d (s, t, r, q);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord4f)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLfloat s;
  if (!ecma_to_GLfloat (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat t;
  if (!ecma_to_GLfloat (argv[1], t))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat r;
  if (!ecma_to_GLfloat (argv[2], r))
    ECMA_ERROR ("argument 2 has wrong type");
  GLfloat q;
  if (!ecma_to_GLfloat (argv[3], q))
    ECMA_ERROR ("argument 3 has wrong type");
  glTexCoord4f (s, t, r, q);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord4i)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLint s;
  if (!ecma_to_GLint (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint t;
  if (!ecma_to_GLint (argv[1], t))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint r;
  if (!ecma_to_GLint (argv[2], r))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint q;
  if (!ecma_to_GLint (argv[3], q))
    ECMA_ERROR ("argument 3 has wrong type");
  glTexCoord4i (s, t, r, q);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord4s)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLshort s;
  if (!ecma_to_GLshort (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort t;
  if (!ecma_to_GLshort (argv[1], t))
    ECMA_ERROR ("argument 1 has wrong type");
  GLshort r;
  if (!ecma_to_GLshort (argv[2], r))
    ECMA_ERROR ("argument 2 has wrong type");
  GLshort q;
  if (!ecma_to_GLshort (argv[3], q))
    ECMA_ERROR ("argument 3 has wrong type");
  glTexCoord4s (s, t, r, q);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord1dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble v[1];
  if (!ecma_to_GLdouble_VEC (argv[0], v, 1))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord1dv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord1fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat v[1];
  if (!ecma_to_GLfloat_VEC (argv[0], v, 1))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord1fv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord1iv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint v[1];
  if (!ecma_to_GLint_VEC (argv[0], v, 1))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord1iv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord1sv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort v[1];
  if (!ecma_to_GLshort_VEC (argv[0], v, 1))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord1sv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord2dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble v[2];
  if (!ecma_to_GLdouble_VEC (argv[0], v, 2))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord2dv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord2fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat v[2];
  if (!ecma_to_GLfloat_VEC (argv[0], v, 2))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord2fv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord2iv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint v[2];
  if (!ecma_to_GLint_VEC (argv[0], v, 2))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord2iv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord2sv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort v[2];
  if (!ecma_to_GLshort_VEC (argv[0], v, 2))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord2sv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord3dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble v[3];
  if (!ecma_to_GLdouble_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord3dv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord3fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat v[3];
  if (!ecma_to_GLfloat_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord3fv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord3iv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint v[3];
  if (!ecma_to_GLint_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord3iv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord3sv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort v[3];
  if (!ecma_to_GLshort_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord3sv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord4dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble v[4];
  if (!ecma_to_GLdouble_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord4dv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord4fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat v[4];
  if (!ecma_to_GLfloat_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord4fv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord4iv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint v[4];
  if (!ecma_to_GLint_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord4iv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexCoord4sv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort v[4];
  if (!ecma_to_GLshort_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glTexCoord4sv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos2d)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLdouble x;
  if (!ecma_to_GLdouble (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble y;
  if (!ecma_to_GLdouble (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  glRasterPos2d (x, y);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos2f)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLfloat x;
  if (!ecma_to_GLfloat (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat y;
  if (!ecma_to_GLfloat (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  glRasterPos2f (x, y);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos2i)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLint x;
  if (!ecma_to_GLint (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  glRasterPos2i (x, y);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos2s)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLshort x;
  if (!ecma_to_GLshort (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort y;
  if (!ecma_to_GLshort (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  glRasterPos2s (x, y);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos3d)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLdouble x;
  if (!ecma_to_GLdouble (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble y;
  if (!ecma_to_GLdouble (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble z;
  if (!ecma_to_GLdouble (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  glRasterPos3d (x, y, z);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos3f)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLfloat x;
  if (!ecma_to_GLfloat (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat y;
  if (!ecma_to_GLfloat (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat z;
  if (!ecma_to_GLfloat (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  glRasterPos3f (x, y, z);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos3i)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLint x;
  if (!ecma_to_GLint (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint z;
  if (!ecma_to_GLint (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  glRasterPos3i (x, y, z);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos3s)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLshort x;
  if (!ecma_to_GLshort (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort y;
  if (!ecma_to_GLshort (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLshort z;
  if (!ecma_to_GLshort (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  glRasterPos3s (x, y, z);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos4d)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLdouble x;
  if (!ecma_to_GLdouble (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble y;
  if (!ecma_to_GLdouble (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble z;
  if (!ecma_to_GLdouble (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  GLdouble w;
  if (!ecma_to_GLdouble (argv[3], w))
    ECMA_ERROR ("argument 3 has wrong type");
  glRasterPos4d (x, y, z, w);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos4f)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLfloat x;
  if (!ecma_to_GLfloat (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat y;
  if (!ecma_to_GLfloat (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat z;
  if (!ecma_to_GLfloat (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  GLfloat w;
  if (!ecma_to_GLfloat (argv[3], w))
    ECMA_ERROR ("argument 3 has wrong type");
  glRasterPos4f (x, y, z, w);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos4i)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLint x;
  if (!ecma_to_GLint (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint z;
  if (!ecma_to_GLint (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint w;
  if (!ecma_to_GLint (argv[3], w))
    ECMA_ERROR ("argument 3 has wrong type");
  glRasterPos4i (x, y, z, w);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos4s)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLshort x;
  if (!ecma_to_GLshort (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort y;
  if (!ecma_to_GLshort (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLshort z;
  if (!ecma_to_GLshort (argv[2], z))
    ECMA_ERROR ("argument 2 has wrong type");
  GLshort w;
  if (!ecma_to_GLshort (argv[3], w))
    ECMA_ERROR ("argument 3 has wrong type");
  glRasterPos4s (x, y, z, w);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos2dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble v[2];
  if (!ecma_to_GLdouble_VEC (argv[0], v, 2))
    ECMA_ERROR ("argument 0 has wrong type");
  glRasterPos2dv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos2fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat v[2];
  if (!ecma_to_GLfloat_VEC (argv[0], v, 2))
    ECMA_ERROR ("argument 0 has wrong type");
  glRasterPos2fv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos2iv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint v[2];
  if (!ecma_to_GLint_VEC (argv[0], v, 2))
    ECMA_ERROR ("argument 0 has wrong type");
  glRasterPos2iv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos2sv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort v[2];
  if (!ecma_to_GLshort_VEC (argv[0], v, 2))
    ECMA_ERROR ("argument 0 has wrong type");
  glRasterPos2sv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos3dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble v[3];
  if (!ecma_to_GLdouble_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glRasterPos3dv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos3fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat v[3];
  if (!ecma_to_GLfloat_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glRasterPos3fv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos3iv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint v[3];
  if (!ecma_to_GLint_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glRasterPos3iv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos3sv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort v[3];
  if (!ecma_to_GLshort_VEC (argv[0], v, 3))
    ECMA_ERROR ("argument 0 has wrong type");
  glRasterPos3sv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos4dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble v[4];
  if (!ecma_to_GLdouble_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glRasterPos4dv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos4fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat v[4];
  if (!ecma_to_GLfloat_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glRasterPos4fv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos4iv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint v[4];
  if (!ecma_to_GLint_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glRasterPos4iv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRasterPos4sv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLshort v[4];
  if (!ecma_to_GLshort_VEC (argv[0], v, 4))
    ECMA_ERROR ("argument 0 has wrong type");
  glRasterPos4sv (v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRectd)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLdouble x1;
  if (!ecma_to_GLdouble (argv[0], x1))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble y1;
  if (!ecma_to_GLdouble (argv[1], y1))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble x2;
  if (!ecma_to_GLdouble (argv[2], x2))
    ECMA_ERROR ("argument 2 has wrong type");
  GLdouble y2;
  if (!ecma_to_GLdouble (argv[3], y2))
    ECMA_ERROR ("argument 3 has wrong type");
  glRectd (x1, y1, x2, y2);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRectf)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLfloat x1;
  if (!ecma_to_GLfloat (argv[0], x1))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat y1;
  if (!ecma_to_GLfloat (argv[1], y1))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat x2;
  if (!ecma_to_GLfloat (argv[2], x2))
    ECMA_ERROR ("argument 2 has wrong type");
  GLfloat y2;
  if (!ecma_to_GLfloat (argv[3], y2))
    ECMA_ERROR ("argument 3 has wrong type");
  glRectf (x1, y1, x2, y2);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRecti)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLint x1;
  if (!ecma_to_GLint (argv[0], x1))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint y1;
  if (!ecma_to_GLint (argv[1], y1))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint x2;
  if (!ecma_to_GLint (argv[2], x2))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint y2;
  if (!ecma_to_GLint (argv[3], y2))
    ECMA_ERROR ("argument 3 has wrong type");
  glRecti (x1, y1, x2, y2);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glRects)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLshort x1;
  if (!ecma_to_GLshort (argv[0], x1))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort y1;
  if (!ecma_to_GLshort (argv[1], y1))
    ECMA_ERROR ("argument 1 has wrong type");
  GLshort x2;
  if (!ecma_to_GLshort (argv[2], x2))
    ECMA_ERROR ("argument 2 has wrong type");
  GLshort y2;
  if (!ecma_to_GLshort (argv[3], y2))
    ECMA_ERROR ("argument 3 has wrong type");
  glRects (x1, y1, x2, y2);
  return JS_TRUE;
}

/* TODO: glRectdv */

/* TODO: glRectfv */

/* TODO: glRectiv */

/* TODO: glRectsv */

/* TODO: glVertexPointer */

/* TODO: glNormalPointer */

/* TODO: glColorPointer */

/* TODO: glIndexPointer */

/* TODO: glTexCoordPointer */

/* TODO: glEdgeFlagPointer */

/* TODO: glGetPointerv */

ECMA_BEGIN_VOID_FUNC (js_glArrayElement)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint i;
  if (!ecma_to_GLint (argv[0], i))
    ECMA_ERROR ("argument 0 has wrong type");
  glArrayElement (i);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glDrawArrays)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum mode;
  if (!ecma_to_GLenum (argv[0], mode))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint first;
  if (!ecma_to_GLint (argv[1], first))
    ECMA_ERROR ("argument 1 has wrong type");
  GLsizei count;
  if (!ecma_to_GLsizei (argv[2], count))
    ECMA_ERROR ("argument 2 has wrong type");
  glDrawArrays (mode, first, count);
  return JS_TRUE;
}

/* TODO: glDrawElements */

/* TODO: glInterleavedArrays */

ECMA_BEGIN_VOID_FUNC (js_glShadeModel)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum mode;
  if (!ecma_to_GLenum (argv[0], mode))
    ECMA_ERROR ("argument 0 has wrong type");
  glShadeModel (mode);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glLightf)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum light;
  if (!ecma_to_GLenum (argv[0], light))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum pname;
  if (!ecma_to_GLenum (argv[1], pname))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat param;
  if (!ecma_to_GLfloat (argv[2], param))
    ECMA_ERROR ("argument 2 has wrong type");
  glLightf (light, pname, param);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glLighti)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum light;
  if (!ecma_to_GLenum (argv[0], light))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum pname;
  if (!ecma_to_GLenum (argv[1], pname))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint param;
  if (!ecma_to_GLint (argv[2], param))
    ECMA_ERROR ("argument 2 has wrong type");
  glLighti (light, pname, param);
  return JS_TRUE;
}

/* TODO: glLightfv */

/* TODO: glLightiv */

/* TODO: glGetLightfv */

/* TODO: glGetLightiv */

ECMA_BEGIN_VOID_FUNC (js_glLightModelf)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum pname;
  if (!ecma_to_GLenum (argv[0], pname))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat param;
  if (!ecma_to_GLfloat (argv[1], param))
    ECMA_ERROR ("argument 1 has wrong type");
  glLightModelf (pname, param);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glLightModeli)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum pname;
  if (!ecma_to_GLenum (argv[0], pname))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint param;
  if (!ecma_to_GLint (argv[1], param))
    ECMA_ERROR ("argument 1 has wrong type");
  glLightModeli (pname, param);
  return JS_TRUE;
}

/* TODO: glLightModelfv */

/* TODO: glLightModeliv */

ECMA_BEGIN_VOID_FUNC (js_glMaterialf)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum face;
  if (!ecma_to_GLenum (argv[0], face))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum pname;
  if (!ecma_to_GLenum (argv[1], pname))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat param;
  if (!ecma_to_GLfloat (argv[2], param))
    ECMA_ERROR ("argument 2 has wrong type");
  glMaterialf (face, pname, param);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMateriali)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum face;
  if (!ecma_to_GLenum (argv[0], face))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum pname;
  if (!ecma_to_GLenum (argv[1], pname))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint param;
  if (!ecma_to_GLint (argv[2], param))
    ECMA_ERROR ("argument 2 has wrong type");
  glMateriali (face, pname, param);
  return JS_TRUE;
}

/* TODO: glMaterialfv */

/* TODO: glMaterialiv */

/* TODO: glGetMaterialfv */

/* TODO: glGetMaterialiv */

ECMA_BEGIN_VOID_FUNC (js_glColorMaterial)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum face;
  if (!ecma_to_GLenum (argv[0], face))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum mode;
  if (!ecma_to_GLenum (argv[1], mode))
    ECMA_ERROR ("argument 1 has wrong type");
  glColorMaterial (face, mode);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glPixelZoom)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLfloat xfactor;
  if (!ecma_to_GLfloat (argv[0], xfactor))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat yfactor;
  if (!ecma_to_GLfloat (argv[1], yfactor))
    ECMA_ERROR ("argument 1 has wrong type");
  glPixelZoom (xfactor, yfactor);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glPixelStoref)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum pname;
  if (!ecma_to_GLenum (argv[0], pname))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat param;
  if (!ecma_to_GLfloat (argv[1], param))
    ECMA_ERROR ("argument 1 has wrong type");
  glPixelStoref (pname, param);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glPixelStorei)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum pname;
  if (!ecma_to_GLenum (argv[0], pname))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint param;
  if (!ecma_to_GLint (argv[1], param))
    ECMA_ERROR ("argument 1 has wrong type");
  glPixelStorei (pname, param);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glPixelTransferf)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum pname;
  if (!ecma_to_GLenum (argv[0], pname))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat param;
  if (!ecma_to_GLfloat (argv[1], param))
    ECMA_ERROR ("argument 1 has wrong type");
  glPixelTransferf (pname, param);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glPixelTransferi)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum pname;
  if (!ecma_to_GLenum (argv[0], pname))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint param;
  if (!ecma_to_GLint (argv[1], param))
    ECMA_ERROR ("argument 1 has wrong type");
  glPixelTransferi (pname, param);
  return JS_TRUE;
}

/* TODO: glPixelMapfv */

/* TODO: glPixelMapuiv */

/* TODO: glPixelMapusv */

/* TODO: glGetPixelMapfv */

/* TODO: glGetPixelMapuiv */

/* TODO: glGetPixelMapusv */

/* TODO: glBitmap */

/* TODO: glReadPixels */

/* TODO: glDrawPixels */

ECMA_BEGIN_VOID_FUNC (js_glCopyPixels)
{
  ECMA_CHECK_NUM_ARGS (5);
  assert (cx == ECMAScript::cx);
  GLint x;
  if (!ecma_to_GLint (argv[0], x))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[1], y))
    ECMA_ERROR ("argument 1 has wrong type");
  GLsizei width;
  if (!ecma_to_GLsizei (argv[2], width))
    ECMA_ERROR ("argument 2 has wrong type");
  GLsizei height;
  if (!ecma_to_GLsizei (argv[3], height))
    ECMA_ERROR ("argument 3 has wrong type");
  GLenum type;
  if (!ecma_to_GLenum (argv[4], type))
    ECMA_ERROR ("argument 4 has wrong type");
  glCopyPixels (x, y, width, height, type);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glStencilFunc)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum func;
  if (!ecma_to_GLenum (argv[0], func))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint ref;
  if (!ecma_to_GLint (argv[1], ref))
    ECMA_ERROR ("argument 1 has wrong type");
  GLuint mask;
  if (!ecma_to_GLuint (argv[2], mask))
    ECMA_ERROR ("argument 2 has wrong type");
  glStencilFunc (func, ref, mask);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glStencilMask)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLuint mask;
  if (!ecma_to_GLuint (argv[0], mask))
    ECMA_ERROR ("argument 0 has wrong type");
  glStencilMask (mask);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glStencilOp)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum fail;
  if (!ecma_to_GLenum (argv[0], fail))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum zfail;
  if (!ecma_to_GLenum (argv[1], zfail))
    ECMA_ERROR ("argument 1 has wrong type");
  GLenum zpass;
  if (!ecma_to_GLenum (argv[2], zpass))
    ECMA_ERROR ("argument 2 has wrong type");
  glStencilOp (fail, zfail, zpass);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glClearStencil)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint s;
  if (!ecma_to_GLint (argv[0], s))
    ECMA_ERROR ("argument 0 has wrong type");
  glClearStencil (s);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexGend)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum coord;
  if (!ecma_to_GLenum (argv[0], coord))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum pname;
  if (!ecma_to_GLenum (argv[1], pname))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble param;
  if (!ecma_to_GLdouble (argv[2], param))
    ECMA_ERROR ("argument 2 has wrong type");
  glTexGend (coord, pname, param);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexGenf)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum coord;
  if (!ecma_to_GLenum (argv[0], coord))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum pname;
  if (!ecma_to_GLenum (argv[1], pname))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat param;
  if (!ecma_to_GLfloat (argv[2], param))
    ECMA_ERROR ("argument 2 has wrong type");
  glTexGenf (coord, pname, param);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexGeni)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum coord;
  if (!ecma_to_GLenum (argv[0], coord))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum pname;
  if (!ecma_to_GLenum (argv[1], pname))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint param;
  if (!ecma_to_GLint (argv[2], param))
    ECMA_ERROR ("argument 2 has wrong type");
  glTexGeni (coord, pname, param);
  return JS_TRUE;
}

/* TODO: glTexGendv */

/* TODO: glTexGenfv */

/* TODO: glTexGeniv */

/* TODO: glGetTexGendv */

/* TODO: glGetTexGenfv */

/* TODO: glGetTexGeniv */

ECMA_BEGIN_VOID_FUNC (js_glTexEnvf)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum pname;
  if (!ecma_to_GLenum (argv[1], pname))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat param;
  if (!ecma_to_GLfloat (argv[2], param))
    ECMA_ERROR ("argument 2 has wrong type");
  glTexEnvf (target, pname, param);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexEnvi)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum pname;
  if (!ecma_to_GLenum (argv[1], pname))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint param;
  if (!ecma_to_GLint (argv[2], param))
    ECMA_ERROR ("argument 2 has wrong type");
  glTexEnvi (target, pname, param);
  return JS_TRUE;
}

/* TODO: glTexEnvfv */

/* TODO: glTexEnviv */

/* TODO: glGetTexEnvfv */

/* TODO: glGetTexEnviv */

ECMA_BEGIN_VOID_FUNC (js_glTexParameterf)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum pname;
  if (!ecma_to_GLenum (argv[1], pname))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat param;
  if (!ecma_to_GLfloat (argv[2], param))
    ECMA_ERROR ("argument 2 has wrong type");
  glTexParameterf (target, pname, param);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glTexParameteri)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum pname;
  if (!ecma_to_GLenum (argv[1], pname))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint param;
  if (!ecma_to_GLint (argv[2], param))
    ECMA_ERROR ("argument 2 has wrong type");
  glTexParameteri (target, pname, param);
  return JS_TRUE;
}

/* TODO: glTexParameterfv */

/* TODO: glTexParameteriv */

/* TODO: glGetTexParameterfv */

/* TODO: glGetTexParameteriv */

/* TODO: glGetTexLevelParameterfv */

/* TODO: glGetTexLevelParameteriv */

/* TODO: glTexImage1D */

/* TODO: glTexImage2D */

/* TODO: glGetTexImage */

#ifdef GL_VERSION_1_1
/* TODO: glGenTextures */

/* TODO: glDeleteTextures */

ECMA_BEGIN_VOID_FUNC (js_glBindTexture)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLuint texture;
  if (!ecma_to_GLuint (argv[1], texture))
    ECMA_ERROR ("argument 1 has wrong type");
  glBindTexture (target, texture);
  return JS_TRUE;
}

/* TODO: glPrioritizeTextures */

/* TODO: glAreTexturesResident */

ECMA_BEGIN_FUNC (js_glIsTexture)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLuint texture;
  if (!ecma_to_GLuint (argv[0], texture))
    ECMA_ERROR ("argument 0 has wrong type");
  GLboolean nres = glIsTexture (texture);
  if (!ecma_from_GLboolean (nres, rval))
    ECMA_ERROR ("could not convert result of type GLboolean");
  return JS_TRUE;
}

/* TODO: glTexSubImage1D */

/* TODO: glTexSubImage2D */

ECMA_BEGIN_VOID_FUNC (js_glCopyTexImage1D)
{
  ECMA_CHECK_NUM_ARGS (7);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint level;
  if (!ecma_to_GLint (argv[1], level))
    ECMA_ERROR ("argument 1 has wrong type");
  GLenum internalformat;
  if (!ecma_to_GLenum (argv[2], internalformat))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint x;
  if (!ecma_to_GLint (argv[3], x))
    ECMA_ERROR ("argument 3 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[4], y))
    ECMA_ERROR ("argument 4 has wrong type");
  GLsizei width;
  if (!ecma_to_GLsizei (argv[5], width))
    ECMA_ERROR ("argument 5 has wrong type");
  GLint border;
  if (!ecma_to_GLint (argv[6], border))
    ECMA_ERROR ("argument 6 has wrong type");
  glCopyTexImage1D (target, level, internalformat, x, y, width, border);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glCopyTexImage2D)
{
  ECMA_CHECK_NUM_ARGS (8);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint level;
  if (!ecma_to_GLint (argv[1], level))
    ECMA_ERROR ("argument 1 has wrong type");
  GLenum internalformat;
  if (!ecma_to_GLenum (argv[2], internalformat))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint x;
  if (!ecma_to_GLint (argv[3], x))
    ECMA_ERROR ("argument 3 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[4], y))
    ECMA_ERROR ("argument 4 has wrong type");
  GLsizei width;
  if (!ecma_to_GLsizei (argv[5], width))
    ECMA_ERROR ("argument 5 has wrong type");
  GLsizei height;
  if (!ecma_to_GLsizei (argv[6], height))
    ECMA_ERROR ("argument 6 has wrong type");
  GLint border;
  if (!ecma_to_GLint (argv[7], border))
    ECMA_ERROR ("argument 7 has wrong type");
  glCopyTexImage2D (target, level, internalformat, x, y, width, height,
		    border);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glCopyTexSubImage1D)
{
  ECMA_CHECK_NUM_ARGS (6);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint level;
  if (!ecma_to_GLint (argv[1], level))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint xoffset;
  if (!ecma_to_GLint (argv[2], xoffset))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint x;
  if (!ecma_to_GLint (argv[3], x))
    ECMA_ERROR ("argument 3 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[4], y))
    ECMA_ERROR ("argument 4 has wrong type");
  GLsizei width;
  if (!ecma_to_GLsizei (argv[5], width))
    ECMA_ERROR ("argument 5 has wrong type");
  glCopyTexSubImage1D (target, level, xoffset, x, y, width);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glCopyTexSubImage2D)
{
  ECMA_CHECK_NUM_ARGS (8);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint level;
  if (!ecma_to_GLint (argv[1], level))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint xoffset;
  if (!ecma_to_GLint (argv[2], xoffset))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint yoffset;
  if (!ecma_to_GLint (argv[3], yoffset))
    ECMA_ERROR ("argument 3 has wrong type");
  GLint x;
  if (!ecma_to_GLint (argv[4], x))
    ECMA_ERROR ("argument 4 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[5], y))
    ECMA_ERROR ("argument 5 has wrong type");
  GLsizei width;
  if (!ecma_to_GLsizei (argv[6], width))
    ECMA_ERROR ("argument 6 has wrong type");
  GLsizei height;
  if (!ecma_to_GLsizei (argv[7], height))
    ECMA_ERROR ("argument 7 has wrong type");
  glCopyTexSubImage2D (target, level, xoffset, yoffset, x, y, width, height);
  return JS_TRUE;
}

/* TODO: glMap1d */

/* TODO: glMap1f */

/* TODO: glMap2d */

/* TODO: glMap2f */

/* TODO: glGetMapdv */

/* TODO: glGetMapfv */

/* TODO: glGetMapiv */

ECMA_BEGIN_VOID_FUNC (js_glEvalCoord1d)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble u;
  if (!ecma_to_GLdouble (argv[0], u))
    ECMA_ERROR ("argument 0 has wrong type");
  glEvalCoord1d (u);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glEvalCoord1f)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat u;
  if (!ecma_to_GLfloat (argv[0], u))
    ECMA_ERROR ("argument 0 has wrong type");
  glEvalCoord1f (u);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glEvalCoord1dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble u[1];
  if (!ecma_to_GLdouble_VEC (argv[0], u, 1))
    ECMA_ERROR ("argument 0 has wrong type");
  glEvalCoord1dv (u);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glEvalCoord1fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat u[1];
  if (!ecma_to_GLfloat_VEC (argv[0], u, 1))
    ECMA_ERROR ("argument 0 has wrong type");
  glEvalCoord1fv (u);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glEvalCoord2d)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLdouble u;
  if (!ecma_to_GLdouble (argv[0], u))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble v;
  if (!ecma_to_GLdouble (argv[1], v))
    ECMA_ERROR ("argument 1 has wrong type");
  glEvalCoord2d (u, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glEvalCoord2f)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLfloat u;
  if (!ecma_to_GLfloat (argv[0], u))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat v;
  if (!ecma_to_GLfloat (argv[1], v))
    ECMA_ERROR ("argument 1 has wrong type");
  glEvalCoord2f (u, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glEvalCoord2dv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble u[2];
  if (!ecma_to_GLdouble_VEC (argv[0], u, 2))
    ECMA_ERROR ("argument 0 has wrong type");
  glEvalCoord2dv (u);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glEvalCoord2fv)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat u[2];
  if (!ecma_to_GLfloat_VEC (argv[0], u, 2))
    ECMA_ERROR ("argument 0 has wrong type");
  glEvalCoord2fv (u);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMapGrid1d)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLint un;
  if (!ecma_to_GLint (argv[0], un))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble u1;
  if (!ecma_to_GLdouble (argv[1], u1))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble u2;
  if (!ecma_to_GLdouble (argv[2], u2))
    ECMA_ERROR ("argument 2 has wrong type");
  glMapGrid1d (un, u1, u2);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMapGrid1f)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLint un;
  if (!ecma_to_GLint (argv[0], un))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat u1;
  if (!ecma_to_GLfloat (argv[1], u1))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat u2;
  if (!ecma_to_GLfloat (argv[2], u2))
    ECMA_ERROR ("argument 2 has wrong type");
  glMapGrid1f (un, u1, u2);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMapGrid2d)
{
  ECMA_CHECK_NUM_ARGS (6);
  assert (cx == ECMAScript::cx);
  GLint un;
  if (!ecma_to_GLint (argv[0], un))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble u1;
  if (!ecma_to_GLdouble (argv[1], u1))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble u2;
  if (!ecma_to_GLdouble (argv[2], u2))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint vn;
  if (!ecma_to_GLint (argv[3], vn))
    ECMA_ERROR ("argument 3 has wrong type");
  GLdouble v1;
  if (!ecma_to_GLdouble (argv[4], v1))
    ECMA_ERROR ("argument 4 has wrong type");
  GLdouble v2;
  if (!ecma_to_GLdouble (argv[5], v2))
    ECMA_ERROR ("argument 5 has wrong type");
  glMapGrid2d (un, u1, u2, vn, v1, v2);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMapGrid2f)
{
  ECMA_CHECK_NUM_ARGS (6);
  assert (cx == ECMAScript::cx);
  GLint un;
  if (!ecma_to_GLint (argv[0], un))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat u1;
  if (!ecma_to_GLfloat (argv[1], u1))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat u2;
  if (!ecma_to_GLfloat (argv[2], u2))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint vn;
  if (!ecma_to_GLint (argv[3], vn))
    ECMA_ERROR ("argument 3 has wrong type");
  GLfloat v1;
  if (!ecma_to_GLfloat (argv[4], v1))
    ECMA_ERROR ("argument 4 has wrong type");
  GLfloat v2;
  if (!ecma_to_GLfloat (argv[5], v2))
    ECMA_ERROR ("argument 5 has wrong type");
  glMapGrid2f (un, u1, u2, vn, v1, v2);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glEvalPoint1)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLint i;
  if (!ecma_to_GLint (argv[0], i))
    ECMA_ERROR ("argument 0 has wrong type");
  glEvalPoint1 (i);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glEvalPoint2)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLint i;
  if (!ecma_to_GLint (argv[0], i))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint j;
  if (!ecma_to_GLint (argv[1], j))
    ECMA_ERROR ("argument 1 has wrong type");
  glEvalPoint2 (i, j);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glEvalMesh1)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum mode;
  if (!ecma_to_GLenum (argv[0], mode))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint i1;
  if (!ecma_to_GLint (argv[1], i1))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint i2;
  if (!ecma_to_GLint (argv[2], i2))
    ECMA_ERROR ("argument 2 has wrong type");
  glEvalMesh1 (mode, i1, i2);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glEvalMesh2)
{
  ECMA_CHECK_NUM_ARGS (5);
  assert (cx == ECMAScript::cx);
  GLenum mode;
  if (!ecma_to_GLenum (argv[0], mode))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint i1;
  if (!ecma_to_GLint (argv[1], i1))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint i2;
  if (!ecma_to_GLint (argv[2], i2))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint j1;
  if (!ecma_to_GLint (argv[3], j1))
    ECMA_ERROR ("argument 3 has wrong type");
  GLint j2;
  if (!ecma_to_GLint (argv[4], j2))
    ECMA_ERROR ("argument 4 has wrong type");
  glEvalMesh2 (mode, i1, i2, j1, j2);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glFogf)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum pname;
  if (!ecma_to_GLenum (argv[0], pname))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat param;
  if (!ecma_to_GLfloat (argv[1], param))
    ECMA_ERROR ("argument 1 has wrong type");
  glFogf (pname, param);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glFogi)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum pname;
  if (!ecma_to_GLenum (argv[0], pname))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint param;
  if (!ecma_to_GLint (argv[1], param))
    ECMA_ERROR ("argument 1 has wrong type");
  glFogi (pname, param);
  return JS_TRUE;
}

/* TODO: glFogfv */

/* TODO: glFogiv */

/* TODO: glFeedbackBuffer */

ECMA_BEGIN_VOID_FUNC (js_glPassThrough)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat token;
  if (!ecma_to_GLfloat (argv[0], token))
    ECMA_ERROR ("argument 0 has wrong type");
  glPassThrough (token);
  return JS_TRUE;
}

/* TODO: glSelectBuffer */

ECMA_BEGIN_VOID_FUNC_VOID (js_glInitNames)
{
  ECMA_CHECK_NUM_ARGS (0);
  assert (cx == ECMAScript::cx);
  glInitNames ();
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glLoadName)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLuint name;
  if (!ecma_to_GLuint (argv[0], name))
    ECMA_ERROR ("argument 0 has wrong type");
  glLoadName (name);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glPushName)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLuint name;
  if (!ecma_to_GLuint (argv[0], name))
    ECMA_ERROR ("argument 0 has wrong type");
  glPushName (name);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC_VOID (js_glPopName)
{
  ECMA_CHECK_NUM_ARGS (0);
  assert (cx == ECMAScript::cx);
  glPopName ();
  return JS_TRUE;
}
#endif
#ifdef GL_VERSION_1_2
/* TODO: glDrawRangeElements */

/* TODO: glTexImage3D */

/* TODO: glTexSubImage3D */

ECMA_BEGIN_VOID_FUNC (js_glCopyTexSubImage3D)
{
  ECMA_CHECK_NUM_ARGS (9);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint level;
  if (!ecma_to_GLint (argv[1], level))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint xoffset;
  if (!ecma_to_GLint (argv[2], xoffset))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint yoffset;
  if (!ecma_to_GLint (argv[3], yoffset))
    ECMA_ERROR ("argument 3 has wrong type");
  GLint zoffset;
  if (!ecma_to_GLint (argv[4], zoffset))
    ECMA_ERROR ("argument 4 has wrong type");
  GLint x;
  if (!ecma_to_GLint (argv[5], x))
    ECMA_ERROR ("argument 5 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[6], y))
    ECMA_ERROR ("argument 6 has wrong type");
  GLsizei width;
  if (!ecma_to_GLsizei (argv[7], width))
    ECMA_ERROR ("argument 7 has wrong type");
  GLsizei height;
  if (!ecma_to_GLsizei (argv[8], height))
    ECMA_ERROR ("argument 8 has wrong type");
  glCopyTexSubImage3D (target, level, xoffset, yoffset, zoffset, x, y, width,
		       height);
  return JS_TRUE;
}

/* TODO: glColorTable */

/* TODO: glColorSubTable */

/* TODO: glColorTableParameteriv */

/* TODO: glColorTableParameterfv */

ECMA_BEGIN_VOID_FUNC (js_glCopyColorSubTable)
{
  ECMA_CHECK_NUM_ARGS (5);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLsizei start;
  if (!ecma_to_GLsizei (argv[1], start))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint x;
  if (!ecma_to_GLint (argv[2], x))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[3], y))
    ECMA_ERROR ("argument 3 has wrong type");
  GLsizei width;
  if (!ecma_to_GLsizei (argv[4], width))
    ECMA_ERROR ("argument 4 has wrong type");
  glCopyColorSubTable (target, start, x, y, width);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glCopyColorTable)
{
  ECMA_CHECK_NUM_ARGS (5);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum internalformat;
  if (!ecma_to_GLenum (argv[1], internalformat))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint x;
  if (!ecma_to_GLint (argv[2], x))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[3], y))
    ECMA_ERROR ("argument 3 has wrong type");
  GLsizei width;
  if (!ecma_to_GLsizei (argv[4], width))
    ECMA_ERROR ("argument 4 has wrong type");
  glCopyColorTable (target, internalformat, x, y, width);
  return JS_TRUE;
}

/* TODO: glGetColorTable */

/* TODO: glGetColorTableParameterfv */

/* TODO: glGetColorTableParameteriv */

ECMA_BEGIN_VOID_FUNC (js_glBlendEquation)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum mode;
  if (!ecma_to_GLenum (argv[0], mode))
    ECMA_ERROR ("argument 0 has wrong type");
  glBlendEquation (mode);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glBlendColor)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLclampf red;
  if (!ecma_to_GLclampf (argv[0], red))
    ECMA_ERROR ("argument 0 has wrong type");
  GLclampf green;
  if (!ecma_to_GLclampf (argv[1], green))
    ECMA_ERROR ("argument 1 has wrong type");
  GLclampf blue;
  if (!ecma_to_GLclampf (argv[2], blue))
    ECMA_ERROR ("argument 2 has wrong type");
  GLclampf alpha;
  if (!ecma_to_GLclampf (argv[3], alpha))
    ECMA_ERROR ("argument 3 has wrong type");
  glBlendColor (red, green, blue, alpha);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glHistogram)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLsizei width;
  if (!ecma_to_GLsizei (argv[1], width))
    ECMA_ERROR ("argument 1 has wrong type");
  GLenum internalformat;
  if (!ecma_to_GLenum (argv[2], internalformat))
    ECMA_ERROR ("argument 2 has wrong type");
  GLboolean sink;
  if (!ecma_to_GLboolean (argv[3], sink))
    ECMA_ERROR ("argument 3 has wrong type");
  glHistogram (target, width, internalformat, sink);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glResetHistogram)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  glResetHistogram (target);
  return JS_TRUE;
}

/* TODO: glGetHistogram */

/* TODO: glGetHistogramParameterfv */

/* TODO: glGetHistogramParameteriv */

ECMA_BEGIN_VOID_FUNC (js_glMinmax)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum internalformat;
  if (!ecma_to_GLenum (argv[1], internalformat))
    ECMA_ERROR ("argument 1 has wrong type");
  GLboolean sink;
  if (!ecma_to_GLboolean (argv[2], sink))
    ECMA_ERROR ("argument 2 has wrong type");
  glMinmax (target, internalformat, sink);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glResetMinmax)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  glResetMinmax (target);
  return JS_TRUE;
}

/* TODO: glGetMinmax */

/* TODO: glGetMinmaxParameterfv */

/* TODO: glGetMinmaxParameteriv */

/* TODO: glConvolutionFilter1D */

/* TODO: glConvolutionFilter2D */

ECMA_BEGIN_VOID_FUNC (js_glConvolutionParameterf)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum pname;
  if (!ecma_to_GLenum (argv[1], pname))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat params;
  if (!ecma_to_GLfloat (argv[2], params))
    ECMA_ERROR ("argument 2 has wrong type");
  glConvolutionParameterf (target, pname, params);
  return JS_TRUE;
}

/* TODO: glConvolutionParameterfv */

ECMA_BEGIN_VOID_FUNC (js_glConvolutionParameteri)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum pname;
  if (!ecma_to_GLenum (argv[1], pname))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint params;
  if (!ecma_to_GLint (argv[2], params))
    ECMA_ERROR ("argument 2 has wrong type");
  glConvolutionParameteri (target, pname, params);
  return JS_TRUE;
}

/* TODO: glConvolutionParameteriv */

ECMA_BEGIN_VOID_FUNC (js_glCopyConvolutionFilter1D)
{
  ECMA_CHECK_NUM_ARGS (5);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum internalformat;
  if (!ecma_to_GLenum (argv[1], internalformat))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint x;
  if (!ecma_to_GLint (argv[2], x))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[3], y))
    ECMA_ERROR ("argument 3 has wrong type");
  GLsizei width;
  if (!ecma_to_GLsizei (argv[4], width))
    ECMA_ERROR ("argument 4 has wrong type");
  glCopyConvolutionFilter1D (target, internalformat, x, y, width);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glCopyConvolutionFilter2D)
{
  ECMA_CHECK_NUM_ARGS (6);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLenum internalformat;
  if (!ecma_to_GLenum (argv[1], internalformat))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint x;
  if (!ecma_to_GLint (argv[2], x))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint y;
  if (!ecma_to_GLint (argv[3], y))
    ECMA_ERROR ("argument 3 has wrong type");
  GLsizei width;
  if (!ecma_to_GLsizei (argv[4], width))
    ECMA_ERROR ("argument 4 has wrong type");
  GLsizei height;
  if (!ecma_to_GLsizei (argv[5], height))
    ECMA_ERROR ("argument 5 has wrong type");
  glCopyConvolutionFilter2D (target, internalformat, x, y, width, height);
  return JS_TRUE;
}

/* TODO: glGetConvolutionFilter */

/* TODO: glGetConvolutionParameterfv */

/* TODO: glGetConvolutionParameteriv */

/* TODO: glSeparableFilter2D */

/* TODO: glGetSeparableFilter */

#endif
#ifdef GL_VERSION_1_3
ECMA_BEGIN_VOID_FUNC (js_glActiveTexture)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum texture;
  if (!ecma_to_GLenum (argv[0], texture))
    ECMA_ERROR ("argument 0 has wrong type");
  glActiveTexture (texture);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glClientActiveTexture)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLenum texture;
  if (!ecma_to_GLenum (argv[0], texture))
    ECMA_ERROR ("argument 0 has wrong type");
  glClientActiveTexture (texture);
  return JS_TRUE;
}

/* TODO: glCompressedTexImage1D */

/* TODO: glCompressedTexImage2D */

/* TODO: glCompressedTexImage3D */

/* TODO: glCompressedTexSubImage1D */

/* TODO: glCompressedTexSubImage2D */

/* TODO: glCompressedTexSubImage3D */

/* TODO: glGetCompressedTexImage */

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord1d)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble s;
  if (!ecma_to_GLdouble (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord1d (target, s);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord1dv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble v[1];
  if (!ecma_to_GLdouble_VEC (argv[1], v, 1))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord1dv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord1f)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat s;
  if (!ecma_to_GLfloat (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord1f (target, s);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord1fv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat v[1];
  if (!ecma_to_GLfloat_VEC (argv[1], v, 1))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord1fv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord1i)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint s;
  if (!ecma_to_GLint (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord1i (target, s);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord1iv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint v[1];
  if (!ecma_to_GLint_VEC (argv[1], v, 1))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord1iv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord1s)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort s;
  if (!ecma_to_GLshort (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord1s (target, s);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord1sv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort v[1];
  if (!ecma_to_GLshort_VEC (argv[1], v, 1))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord1sv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord2d)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble s;
  if (!ecma_to_GLdouble (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble t;
  if (!ecma_to_GLdouble (argv[2], t))
    ECMA_ERROR ("argument 2 has wrong type");
  glMultiTexCoord2d (target, s, t);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord2dv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble v[2];
  if (!ecma_to_GLdouble_VEC (argv[1], v, 2))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord2dv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord2f)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat s;
  if (!ecma_to_GLfloat (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat t;
  if (!ecma_to_GLfloat (argv[2], t))
    ECMA_ERROR ("argument 2 has wrong type");
  glMultiTexCoord2f (target, s, t);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord2fv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat v[2];
  if (!ecma_to_GLfloat_VEC (argv[1], v, 2))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord2fv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord2i)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint s;
  if (!ecma_to_GLint (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint t;
  if (!ecma_to_GLint (argv[2], t))
    ECMA_ERROR ("argument 2 has wrong type");
  glMultiTexCoord2i (target, s, t);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord2iv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint v[2];
  if (!ecma_to_GLint_VEC (argv[1], v, 2))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord2iv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord2s)
{
  ECMA_CHECK_NUM_ARGS (3);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort s;
  if (!ecma_to_GLshort (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  GLshort t;
  if (!ecma_to_GLshort (argv[2], t))
    ECMA_ERROR ("argument 2 has wrong type");
  glMultiTexCoord2s (target, s, t);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord2sv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort v[2];
  if (!ecma_to_GLshort_VEC (argv[1], v, 2))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord2sv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord3d)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble s;
  if (!ecma_to_GLdouble (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble t;
  if (!ecma_to_GLdouble (argv[2], t))
    ECMA_ERROR ("argument 2 has wrong type");
  GLdouble r;
  if (!ecma_to_GLdouble (argv[3], r))
    ECMA_ERROR ("argument 3 has wrong type");
  glMultiTexCoord3d (target, s, t, r);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord3dv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble v[3];
  if (!ecma_to_GLdouble_VEC (argv[1], v, 3))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord3dv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord3f)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat s;
  if (!ecma_to_GLfloat (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat t;
  if (!ecma_to_GLfloat (argv[2], t))
    ECMA_ERROR ("argument 2 has wrong type");
  GLfloat r;
  if (!ecma_to_GLfloat (argv[3], r))
    ECMA_ERROR ("argument 3 has wrong type");
  glMultiTexCoord3f (target, s, t, r);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord3fv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat v[3];
  if (!ecma_to_GLfloat_VEC (argv[1], v, 3))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord3fv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord3i)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint s;
  if (!ecma_to_GLint (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint t;
  if (!ecma_to_GLint (argv[2], t))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint r;
  if (!ecma_to_GLint (argv[3], r))
    ECMA_ERROR ("argument 3 has wrong type");
  glMultiTexCoord3i (target, s, t, r);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord3iv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint v[3];
  if (!ecma_to_GLint_VEC (argv[1], v, 3))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord3iv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord3s)
{
  ECMA_CHECK_NUM_ARGS (4);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort s;
  if (!ecma_to_GLshort (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  GLshort t;
  if (!ecma_to_GLshort (argv[2], t))
    ECMA_ERROR ("argument 2 has wrong type");
  GLshort r;
  if (!ecma_to_GLshort (argv[3], r))
    ECMA_ERROR ("argument 3 has wrong type");
  glMultiTexCoord3s (target, s, t, r);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord3sv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort v[3];
  if (!ecma_to_GLshort_VEC (argv[1], v, 3))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord3sv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord4d)
{
  ECMA_CHECK_NUM_ARGS (5);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble s;
  if (!ecma_to_GLdouble (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  GLdouble t;
  if (!ecma_to_GLdouble (argv[2], t))
    ECMA_ERROR ("argument 2 has wrong type");
  GLdouble r;
  if (!ecma_to_GLdouble (argv[3], r))
    ECMA_ERROR ("argument 3 has wrong type");
  GLdouble q;
  if (!ecma_to_GLdouble (argv[4], q))
    ECMA_ERROR ("argument 4 has wrong type");
  glMultiTexCoord4d (target, s, t, r, q);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord4dv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLdouble v[4];
  if (!ecma_to_GLdouble_VEC (argv[1], v, 4))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord4dv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord4f)
{
  ECMA_CHECK_NUM_ARGS (5);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat s;
  if (!ecma_to_GLfloat (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  GLfloat t;
  if (!ecma_to_GLfloat (argv[2], t))
    ECMA_ERROR ("argument 2 has wrong type");
  GLfloat r;
  if (!ecma_to_GLfloat (argv[3], r))
    ECMA_ERROR ("argument 3 has wrong type");
  GLfloat q;
  if (!ecma_to_GLfloat (argv[4], q))
    ECMA_ERROR ("argument 4 has wrong type");
  glMultiTexCoord4f (target, s, t, r, q);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord4fv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLfloat v[4];
  if (!ecma_to_GLfloat_VEC (argv[1], v, 4))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord4fv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord4i)
{
  ECMA_CHECK_NUM_ARGS (5);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint s;
  if (!ecma_to_GLint (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  GLint t;
  if (!ecma_to_GLint (argv[2], t))
    ECMA_ERROR ("argument 2 has wrong type");
  GLint r;
  if (!ecma_to_GLint (argv[3], r))
    ECMA_ERROR ("argument 3 has wrong type");
  GLint q;
  if (!ecma_to_GLint (argv[4], q))
    ECMA_ERROR ("argument 4 has wrong type");
  glMultiTexCoord4i (target, s, t, r, q);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord4iv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLint v[4];
  if (!ecma_to_GLint_VEC (argv[1], v, 4))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord4iv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord4s)
{
  ECMA_CHECK_NUM_ARGS (5);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort s;
  if (!ecma_to_GLshort (argv[1], s))
    ECMA_ERROR ("argument 1 has wrong type");
  GLshort t;
  if (!ecma_to_GLshort (argv[2], t))
    ECMA_ERROR ("argument 2 has wrong type");
  GLshort r;
  if (!ecma_to_GLshort (argv[3], r))
    ECMA_ERROR ("argument 3 has wrong type");
  GLshort q;
  if (!ecma_to_GLshort (argv[4], q))
    ECMA_ERROR ("argument 4 has wrong type");
  glMultiTexCoord4s (target, s, t, r, q);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultiTexCoord4sv)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLenum target;
  if (!ecma_to_GLenum (argv[0], target))
    ECMA_ERROR ("argument 0 has wrong type");
  GLshort v[4];
  if (!ecma_to_GLshort_VEC (argv[1], v, 4))
    ECMA_ERROR ("argument 1 has wrong type");
  glMultiTexCoord4sv (target, v);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glLoadTransposeMatrixd)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble m[16];
  if (!ecma_to_GLdouble_VEC (argv[0], m, 16))
    ECMA_ERROR ("argument 0 has wrong type");
  glLoadTransposeMatrixd (m);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glLoadTransposeMatrixf)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat m[16];
  if (!ecma_to_GLfloat_VEC (argv[0], m, 16))
    ECMA_ERROR ("argument 0 has wrong type");
  glLoadTransposeMatrixf (m);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultTransposeMatrixd)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLdouble m[16];
  if (!ecma_to_GLdouble_VEC (argv[0], m, 16))
    ECMA_ERROR ("argument 0 has wrong type");
  glMultTransposeMatrixd (m);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glMultTransposeMatrixf)
{
  ECMA_CHECK_NUM_ARGS (1);
  assert (cx == ECMAScript::cx);
  GLfloat m[16];
  if (!ecma_to_GLfloat_VEC (argv[0], m, 16))
    ECMA_ERROR ("argument 0 has wrong type");
  glMultTransposeMatrixf (m);
  return JS_TRUE;
}

ECMA_BEGIN_VOID_FUNC (js_glSampleCoverage)
{
  ECMA_CHECK_NUM_ARGS (2);
  assert (cx == ECMAScript::cx);
  GLclampf value;
  if (!ecma_to_GLclampf (argv[0], value))
    ECMA_ERROR ("argument 0 has wrong type");
  GLboolean invert;
  if (!ecma_to_GLboolean (argv[1], invert))
    ECMA_ERROR ("argument 1 has wrong type");
  glSampleCoverage (value, invert);
  return JS_TRUE;
}
#endif
